package JavaCode.contest.weekly.n201_300.n240;

import utils.Parse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class N4 {
    //TODO 超时
    //"zaazazwlqqwaazlalwqaaqllzzzwzqlazqaazqlaqlllzqzzalqzwalwlzwzqwzqzaqzwllzlqwlqwwqawqzlqzallwlqaqq"
    //[[0,1],[0,2],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[6,8],[7,9],[8,9],[4,9],[8,10],[9,10],[5,10],[6,11],[10,11],[11,12],[12,13],[9,13],[10,13],[13,14],[10,14],[13,15],[9,15],[14,15],[15,16],[11,16],[12,17],[16,17],[17,18],[8,18],[15,18],[14,18],[10,19],[17,19],[18,19],[18,20],[17,21],[15,21],[18,21],[21,22],[20,22],[17,23],[21,23],[20,23],[22,23],[19,24],[22,24],[24,25],[23,25],[20,25],[22,26],[16,27],[18,27],[22,28],[27,29],[18,29],[20,29],[10,29],[29,30],[28,30],[28,31],[29,32],[17,32],[30,32],[27,33],[31,34],[34,35],[35,36],[27,36],[31,37],[36,37],[35,38],[38,39],[32,39],[39,40],[40,41],[33,41],[39,41],[36,41],[26,42],[39,42],[34,42],[29,42],[36,42],[41,43],[42,43],[37,43],[42,44],[40,44],[43,44],[23,44],[29,45],[35,46],[28,46],[44,46],[41,47],[44,47],[45,47],[42,48],[44,49],[39,49],[37,49],[45,49],[32,49],[46,50],[47,50],[36,50],[48,50],[49,50],[46,51],[50,51],[50,52],[37,52],[31,53],[37,54],[49,54],[52,54],[40,55],[52,55],[41,55],[54,55],[45,56],[53,56],[55,57],[54,57],[50,57],[47,57],[31,58],[56,58],[56,59],[59,60],[52,60],[50,60],[58,60],[52,61],[50,61],[58,61],[56,61],[61,62],[54,63],[34,63],[28,64],[11,64],[61,64],[52,64],[41,64],[36,65],[33,65],[62,65],[52,65],[65,66],[61,67],[65,67],[59,67],[60,67],[67,68],[66,68],[56,68],[64,68],[65,69],[64,69],[65,70],[70,71],[42,71],[52,72],[53,72],[55,72],[70,73],[65,74],[68,74],[73,74],[72,74],[15,74],[60,75],[69,75],[73,75],[70,75],[72,76],[54,76],[53,76],[74,76],[68,77],[75,77],[71,77],[76,77],[69,77],[72,78],[55,78],[76,78],[60,78],[77,78],[69,79],[74,79],[75,79],[77,79],[78,80],[52,81],[74,81],[78,81],[47,82],[79,82],[81,82],[66,82],[78,83],[81,83],[75,84],[80,84],[38,84],[77,84],[75,85],[80,85],[59,85],[78,86],[84,86],[68,86],[86,87],[85,87],[57,88],[86,88],[77,88],[62,88],[36,89],[89,90],[88,90],[85,91],[88,91],[89,91],[91,92],[82,92],[76,92],[86,92],[71,92],[91,93],[69,93],[82,93],[86,94],[39,94],[83,94],[87,94],[76,95],[94,95],[67,95]]
    public static void main(String[] args) {
        System.out.println(new N4().largestPathValue("zaazazwlqqwaazlalwqaaqllzzzwzqlazqaazqlaqlllzqzzalqzwalwlzwzqwzqzaqzwllzlqwlqwwqawqzlqzallwlqaqq",
                Parse.parseToIntTwoArray("[[0,1],[0,2],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[6,8],[7,9],[8,9],[4,9],[8,10],[9,10],[5,10],[6,11],[10,11],[11,12],[12,13],[9,13],[10,13],[13,14],[10,14],[13,15],[9,15],[14,15],[15,16],[11,16],[12,17],[16,17],[17,18],[8,18],[15,18],[14,18],[10,19],[17,19],[18,19],[18,20],[17,21],[15,21],[18,21],[21,22],[20,22],[17,23],[21,23],[20,23],[22,23],[19,24],[22,24],[24,25],[23,25],[20,25],[22,26],[16,27],[18,27],[22,28],[27,29],[18,29],[20,29],[10,29],[29,30],[28,30],[28,31],[29,32],[17,32],[30,32],[27,33],[31,34],[34,35],[35,36],[27,36],[31,37],[36,37],[35,38],[38,39],[32,39],[39,40],[40,41],[33,41],[39,41],[36,41],[26,42],[39,42],[34,42],[29,42],[36,42],[41,43],[42,43],[37,43],[42,44],[40,44],[43,44],[23,44],[29,45],[35,46],[28,46],[44,46],[41,47],[44,47],[45,47],[42,48],[44,49],[39,49],[37,49],[45,49],[32,49],[46,50],[47,50],[36,50],[48,50],[49,50],[46,51],[50,51],[50,52],[37,52],[31,53],[37,54],[49,54],[52,54],[40,55],[52,55],[41,55],[54,55],[45,56],[53,56],[55,57],[54,57],[50,57],[47,57],[31,58],[56,58],[56,59],[59,60],[52,60],[50,60],[58,60],[52,61],[50,61],[58,61],[56,61],[61,62],[54,63],[34,63],[28,64],[11,64],[61,64],[52,64],[41,64],[36,65],[33,65],[62,65],[52,65],[65,66],[61,67],[65,67],[59,67],[60,67],[67,68],[66,68],[56,68],[64,68],[65,69],[64,69],[65,70],[70,71],[42,71],[52,72],[53,72],[55,72],[70,73],[65,74],[68,74],[73,74],[72,74],[15,74],[60,75],[69,75],[73,75],[70,75],[72,76],[54,76],[53,76],[74,76],[68,77],[75,77],[71,77],[76,77],[69,77],[72,78],[55,78],[76,78],[60,78],[77,78],[69,79],[74,79],[75,79],[77,79],[78,80],[52,81],[74,81],[78,81],[47,82],[79,82],[81,82],[66,82],[78,83],[81,83],[75,84],[80,84],[38,84],[77,84],[75,85],[80,85],[59,85],[78,86],[84,86],[68,86],[86,87],[85,87],[57,88],[86,88],[77,88],[62,88],[36,89],[89,90],[88,90],[85,91],[88,91],[89,91],[91,92],[82,92],[76,92],[86,92],[71,92],[91,93],[69,93],[82,93],[86,94],[39,94],[83,94],[87,94],[76,95],[94,95],[67,95]]"
                        )));
    }
    private int res;
    private boolean ok;
    private List<Integer> empty=new ArrayList<>(1);
    public int largestPathValue(String colors, int[][] edges) {
        final char[] c = colors.toCharArray();
        final Map<Integer, List<Integer>> graph=new HashMap<>();
        int n=colors.length()-1;
        boolean[] b=new boolean[n+1];
        for (int[] e:edges){
            if(!graph.containsKey(e[0]))graph.put(e[0],new ArrayList<>());
            graph.get(e[0]).add(e[1]);
            b[e[1]]=true;
            if(e[0]==e[1])return -1;
        }
        res=0;
        ok=true;
        boolean[] book=new boolean[n+1];
        for (int i=0;i<=n;i++){
            if(!ok)return -1;
            if(book[i]||b[i])continue;
            book[i]=true;
            dfs(i,c,graph,book,new int[26],new boolean[n+1]);
        }
        if(!ok)return -1;
        return res==0?-1:res;
    }

    private void dfs(int idx, char[] c, Map<Integer, List<Integer>> graph, boolean[] book, int[] cnt, boolean[] book2) {
        if(!ok)return;
        book[idx]=true;
        if(book2[idx]){
            ok=false;
            return;
        }
        book2[idx]=true;
        cnt[c[idx]-'a']++;
        res=Math.max(res,cnt[c[idx]-'a']);
        final List<Integer> nexts = graph.getOrDefault(idx,empty);
        for (int next:nexts){
            dfs(next,c,graph,book,cnt, book2);
        }
        book2[idx]=false;
    }
}
/*
给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。

给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。

图中一条有效 路径 是一个点序列 x1 -> x2 -> x3 -> ... -> xk ，对于所有 1 <= i < k ，从 xi 到 xi+1 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。

请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。



示例 1：



输入：colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]
输出：3
解释：路径 0 -> 2 -> 3 -> 4 含有 3 个颜色为 "a" 的节点（上图中的红色节点）。
示例 2：



输入：colors = "a", edges = [[0,0]]
输出：-1
解释：从 0 到 0 有一个环。


提示：

n == colors.length
m == edges.length
1 <= n <= 105
0 <= m <= 105
colors 只含有小写英文字母。
0 <= aj, bj < n
 */
